namespace com.sap.resourceManagement.system.data.timeBucket;

using { managed } from '@sap/cds/common';
using com.sap.resourceManagement.system.data.timeDimension as timeDimension from './timeDimension';

//Bucket Type as Minutes integer value
type TypeCode : String(2) enum {
    year        = '01';
    quarter     = '02';
    month       = '03';
    week        = '04';
    day         = '05';
    hour        = '06';
    halfAnHour  = '07';
    quarterHour = '08';
};

//Time Bucket Types with Text table - more for value help
entity Types {
    key code        : TypeCode;
        description : String(100);
};

/*
System metadata - TimeBuckets are generated by system through a batch job periodically and automatically.
How to Generate?
- Input can be Year (or nextYear)
- Entries are generated for the whole year
- Batch job always checks if Time buckets are available for next 2 years.  If not, it automatically generates these entries

Records are generated for 24 hours * 365 days

Procedure RM_FILL_TIME_BUCKETS is used to fill time dimension data.

Size Info:
For year, quarter, month, week, day, hour, halfAnHour, quarterHour time buckets;
for one year, the size on the DB is 1.6 MB

0.22 MB for Two years of data for year/quarter/month/week/day time buckets
*/

entity Data {
    //We will always have up to minute entries in startTime, endTime.
    //we will not store seconds / microseconds
    key type_code         : TypeCode;
    key startTime         : Timestamp;
        endTime           : Timestamp;
        durationInMinutes : Integer;
        type              : Association to one Types on type.code = type_code;
        toTimeDimension   : Association to one timeDimension.Data on toTimeDimension.DATETIMESTAMP = startTime;
        @odata.navigable : false
        toSmallestMap     : Association to many MapWithSmallestWindow on toSmallestMap.bigBucket_type_code = type_code and toSmallestMap.bigBucket_startTime = startTime;
};

/*
Mapping between bigger time bucket to smaller time bucket
Pre-generated system metadata.

This is an attempt to avoid >= and < Operators in Join conditions.
We would like to check if the performance gets better with that.

For any higher time bucket, if suitable mapping is generated to lowest time bucket
supported, then we can avoid >= and < operator.

Size Info:
0.12 MB for Two years of data for year/quarter/month/week/day time buckets
*/
entity Map {
    key bigBucket_type_code      : TypeCode;
    key bigBucket_startTime      : Timestamp;
    key smallBucket_type_code    : TypeCode;
    key smallBucket_startTime    : Timestamp;
        bigBucket                : Association to one Data on bigBucket.type_code = bigBucket_type_code and bigBucket.startTime = bigBucket_startTime;
        smallBucket              : Association to one Data on smallBucket.type_code = smallBucket_type_code and smallBucket.startTime = smallBucket_startTime;
        smallBucketTimeDimension : Association to timeDimension.Data on smallBucketTimeDimension.DATETIMESTAMP = smallBucket_startTime;
        toTypeWithSmallestWindow : Association to one TypeWithSmallestWindow on toTypeWithSmallestWindow.type_code = smallBucket_type_code;
};

/*
Generation Info for individual TypeCodes.  For performance during selections
*/
entity GenerationInfo {
    key type_code : TypeCode;
        endTime   : Timestamp;
        type      : Association to one Types on type.code = type_code;
};

/*
The Smallest Time Bucket for which data was generated in the system.
It can be days in the case of professional services.
If the smallest time bucket type is 15 minutes, we will have analysis
enabled up to 15 minute time buckets.
*/
entity TypeWithSmallestWindow as select from GenerationInfo {
    key type_code,
        type
} order by type_code desc limit 1 offset 0;

entity MapWithSmallestWindow as select from Map {
    *
} where toTypeWithSmallestWindow.type_code is not null;