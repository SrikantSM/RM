package com.sap.c4p.rm.consultantprofile.cloudfoundry.service.malwarescan;

import java.time.Duration;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.function.Supplier;

import com.sap.c4p.rm.consultantprofile.gen.MessageKeys;
import com.sap.cds.services.messages.Messages;
import myprojectexperienceservice.Attachment_;
import myprojectexperienceservice.ProfilePhoto_;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import com.sap.c4p.rm.consultantprofile.config.LoggingMarker;

import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.timelimiter.TimeLimiter;
import io.github.resilience4j.timelimiter.TimeLimiterConfig;
import io.github.resilience4j.timelimiter.TimeLimiterRegistry;
import io.pivotal.cfenv.core.CfEnv;
import io.pivotal.cfenv.core.CfService;
import io.vavr.control.Try;

@Service
public class MalwareScanServiceImpl implements MalwareScanService {

    private final WebClient webClient;
    private final CfEnv cfEnv;
    private final Environment environment;

    private static final Logger LOGGER = LoggerFactory.getLogger(MalwareScanServiceImpl.class);
    private static final Marker MARKER = LoggingMarker.MALWARE_SCANNING_MARKER.getMarker();
    private static final String HTTPS = "https://";
    private static final String API = "/scan";
    private static final String MALWARE_SCANNER_SERVICE = "malware-scanner";
    private static final String MALWARE_SCANNER_URL = "uri";

    protected static final String TIME_LIMITER_NAME = "MalwareScanningTimeLimiter";
    protected static final String MALWARE_SERVICE_TIMEOUT = "MALWARE_SERVICE_TIMEOUT";
    protected static final String MALWARE_SERVICE_RETRY_ATTEMPT = "MALWARE_SERVICE_RETRY_ATTEMPT";
    protected static final Integer DEFAULT_MALWARE_SERVICE_RETRY_ATTEMPT = 2;
    private static final String PROFILE_PHOTO_ASSIGNMENT_OBJECT_TYPE = "ProfilePhoto";
    private static final String RESUME = "Resume";

    private Integer malwareServiceTimeout;
    private Integer malwareServiceRetryAttempt;

    @Autowired
    public MalwareScanServiceImpl(WebClient webClient, CfEnv cfEnv, Environment environment) {
        this.webClient = webClient;
        this.cfEnv = cfEnv;
        this.environment = environment;
    }

    @Override
    /**
     * This method calls the malware scanning service and returns if the byte array
     * is malicious or not
     *
     * @param byte array of the file which needs to be scanned
     * @return returns an object which will contain malware scan result
     */
    public MalwareScanResponse scanMalware(byte[] content, Integer timeout, Messages messages, String entity) {
        Integer malwareServiceTimeoutFromEnv;
        Integer malwareServiceRetryAttemptFromEnv;
        CfService malwareScannerService = this.cfEnv.findServiceByLabel(MALWARE_SCANNER_SERVICE);
        String malwareScannerUrl = HTTPS + malwareScannerService.getCredentials().getString(MALWARE_SCANNER_URL) + API;

        if ((malwareServiceRetryAttemptFromEnv = this.environment.getProperty(MALWARE_SERVICE_RETRY_ATTEMPT,
                Integer.class)) == null)
            malwareServiceRetryAttemptFromEnv = DEFAULT_MALWARE_SERVICE_RETRY_ATTEMPT;
        if ((malwareServiceTimeoutFromEnv = this.environment.getProperty(MALWARE_SERVICE_TIMEOUT,
                Integer.class)) == null)
            malwareServiceTimeoutFromEnv = timeout;
        this.malwareServiceRetryAttempt = malwareServiceRetryAttemptFromEnv;
        this.malwareServiceTimeout = malwareServiceTimeoutFromEnv;

        HttpHeaders headers = new HttpHeaders();
        headers.setBasicAuth(malwareScannerService.getCredentials().getUsername(),
                malwareScannerService.getCredentials().getPassword());
        HttpEntity<Object> requestEntity = new HttpEntity<>(content, headers);
        MalwareScanResponse response = request(MARKER, malwareScannerUrl, requestEntity, MalwareScanResponse.class,
                content, messages, entity);
        if (response == null) {
            return null;
        }
        LOGGER.info(MARKER, "Malware Detected: {}, Detected Mime Type: {}", response.getMalwareDetected(),
                response.getMimeType());
        return response;
    }

    public MalwareScanResponse request(final Marker loggingMarker, final String url, final HttpEntity<Object> requestEntity,
                                       final Class<MalwareScanResponse> responseType, byte[] content, Messages messages, String entity) {
        TimeLimiterConfig timeLimiterConfig = TimeLimiterConfig.custom()
                .timeoutDuration(Duration.ofMillis(this.malwareServiceTimeout)).cancelRunningFuture(false).build();
        TimeLimiterRegistry timeLimiterRegistry = TimeLimiterRegistry.of(timeLimiterConfig);
        TimeLimiter timeLimiter = timeLimiterRegistry.timeLimiter(TIME_LIMITER_NAME);

        RetryConfig retryConfig = RetryConfig.custom().maxAttempts(this.malwareServiceRetryAttempt).build();
        Retry retry = Retry.of("MalwareScanningService", retryConfig);

        Supplier<CompletableFuture<ResponseEntity<MalwareScanResponse>>> futureSupplier = () -> CompletableFuture
                .supplyAsync(() -> this.webClient.method(HttpMethod.POST).uri(url).bodyValue(content)
                        .headers(httpHeaders -> httpHeaders.addAll(requestEntity.getHeaders())).retrieve()
                        .toEntity(responseType).block());
        Callable<ResponseEntity<MalwareScanResponse>> callable = TimeLimiter.decorateFutureSupplier(timeLimiter,
                futureSupplier);
        callable = Retry.decorateCallable(retry, callable);
        Try<ResponseEntity<MalwareScanResponse>> responseResult = Try.ofCallable(callable)
                .recover(throwable -> fallbackForMalwareScanning(loggingMarker, url, throwable, messages, entity));

        ResponseEntity<MalwareScanResponse> result;
        if ((result = responseResult.get()) != null)
            return result.getBody();
        else
            return null;
    }

    private <T> ResponseEntity<T> fallbackForMalwareScanning(final Marker loggingMarker, final String url,
                                                             final Throwable httpException, Messages messages, String entity) {
        if (httpException instanceof WebClientResponseException) {
            WebClientResponseException webClientResponseException = (WebClientResponseException) httpException;
            LOGGER.error(loggingMarker, "{} {} returned error code {}. Response Body: {} Message: {}", HttpMethod.POST,
                    url, webClientResponseException.getRawStatusCode(),
                    webClientResponseException.getResponseBodyAsString(), httpException.getMessage());
            logError(messages, entity, MessageKeys.PROFILE_UPLOAD_IO_ERROR);
        }
        if (httpException instanceof TimeoutException) {
            TimeoutException timeoutException = (TimeoutException) httpException;
            LOGGER.error(loggingMarker, "Malware Scanning service took longer than expected: {}",
                    timeoutException.getMessage());
            logError(messages, entity, MessageKeys.MALWARE_SCANNING_ERROR);
        }
        return null;
    }

    private void logError(Messages messages, String entity, String messageKey) {
        if(entity.equalsIgnoreCase(PROFILE_PHOTO_ASSIGNMENT_OBJECT_TYPE))
            messages.error(messageKey).target("in", ProfilePhoto_.class,
                photo -> photo.profileImage());
        if(entity.equalsIgnoreCase(RESUME))
            messages.error(messageKey).target("in", Attachment_.class,
                resume -> resume.content());
        messages.throwIfError();
    }
}
