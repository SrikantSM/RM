package com.sap.c4p.rm.consultantprofile.cloudfoundry.service.malwarescan;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.List;
import java.util.function.Consumer;

import com.sap.c4p.rm.consultantprofile.gen.MessageKeys;
import com.sap.cds.services.messages.Messages;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.Answers;
import org.mockito.Mock;
import org.mockito.internal.stubbing.answers.AnswersWithDelay;
import org.mockito.internal.stubbing.answers.Returns;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;

import com.sap.c4p.rm.consultantprofile.InitMocks;
import com.sap.c4p.rm.consultantprofile.utils.StringFormatter;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.read.ListAppender;
import io.pivotal.cfenv.core.CfCredentials;
import io.pivotal.cfenv.core.CfEnv;
import io.pivotal.cfenv.core.CfService;
import io.vavr.control.Try;
import reactor.core.publisher.Mono;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class MalwareScanServiceTest extends InitMocks {

    private final Logger logger = (Logger) LoggerFactory.getLogger(MalwareScanServiceImpl.class);

    private static final String DUMMY_URL = "dummyUrl";
    private static final String DUMMY_USERNAME = "dummyUsername";
    private static final String DUMMY_PASSWORD = "dummyPassword";
    private static final String DUMMY_STRING = "String";
    private static final String DUMMY_MALWARE_SERVICE_TIMEOUT = "MALWARE_SERVICE_TIMEOUT";
    private static final String HTTP_ERROR_RESPONSE_BODY = "Error response body";
    private static final String SOMETHING_WENT_WRONG = "SOMETHING_WENT_WRONG";
    private static final String DUMMY_FINDING = "dummyFinding";
    private static final String DUMMY_MIMETYPE = "dummyMimetype";
    private static final String DUMMY_SHA256 = "dummySHA256";
    private static final Integer DEFAULT_TIMEOUT = 1000;

    @Mock
    WebClient webClient;

    @Mock
    CfEnv cfEnv;

    @Mock
    CfService cfService;

    @Mock
    CfCredentials cfCredentials;

    @Mock
    Environment environment;

    @Mock
    WebClientResponseException webClientResponseException;

    @Mock
    WebClient.RequestHeadersUriSpec requestHeadersUriSpecMock;

    @Mock
    WebClient.RequestHeadersSpec requestHeadersSpecMock1;

    @Mock
    WebClient.RequestHeadersSpec requestHeadersSpecMock2;

    @Mock
    WebClient.RequestBodyUriSpec requestBodyUriSpec;

    @Mock
    WebClient.RequestBodySpec requestBodySpec;

    @Mock
    WebClient.ResponseSpec responseSpecMock;

    @Mock
    Mono<ResponseEntity<MalwareScanResponse>> responseEntityMock;

    @Mock
    Try<ResponseEntity<MalwareScanResponse>> responseResult;

    @Mock
    Marker marker;

    @Mock(answer = Answers.RETURNS_DEEP_STUBS)
    private Messages messages;

    private ListAppender<ILoggingEvent> listAppender;
    private MalwareScanServiceImpl malwareScanServiceImpl;
    private MalwareScanResponse malwareScanResponse;

    @BeforeEach
    void setUp() {
        when(cfEnv.findServiceByLabel(anyString())).thenReturn(cfService);
        when(cfService.getCredentials()).thenReturn(cfCredentials);
        when(cfCredentials.getString(anyString())).thenReturn(DUMMY_URL);
        when(cfCredentials.getUsername()).thenReturn(DUMMY_USERNAME);
        when(cfCredentials.getPassword()).thenReturn(DUMMY_PASSWORD);

        this.malwareScanResponse = new MalwareScanResponse();
        this.malwareScanResponse.setEncryptedContentDetected(false);
        this.malwareScanResponse.setFinding(DUMMY_FINDING);
        this.malwareScanResponse.setMimeType(DUMMY_MIMETYPE);
        this.malwareScanResponse.setScanSize(2000000);
        this.malwareScanResponse.setSHA256(DUMMY_SHA256);

        this.malwareScanServiceImpl = new MalwareScanServiceImpl(this.webClient, this.cfEnv, this.environment);

        this.listAppender = new ListAppender<>();
        this.listAppender.start();
        logger.addAppender(listAppender);
    }

    @Test
    @Order(4)
    @DisplayName("test when malware scan service returns something.")
    void testResponseWhenMalwareScanServiceReturnSomething() {
        ResponseEntity<MalwareScanResponse> result = new ResponseEntity<>(malwareScanResponse, HttpStatus.OK);
        this.malwareScanResponse.setMalwareDetected(false);

        when(this.environment.getProperty(DUMMY_MALWARE_SERVICE_TIMEOUT, Integer.class)).thenReturn(DEFAULT_TIMEOUT);
        when(this.webClient.method(HttpMethod.POST)).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.bodyValue(DUMMY_STRING.getBytes())).thenReturn(requestHeadersSpecMock1);
        when(requestHeadersSpecMock1.headers(any(Consumer.class))).thenReturn(requestHeadersSpecMock2);
        when(requestHeadersSpecMock2.retrieve()).thenReturn(responseSpecMock);
        when(responseSpecMock.toEntity(MalwareScanResponse.class)).thenReturn(responseEntityMock);
        when(responseEntityMock.block()).thenReturn(result);
        assertEquals(malwareScanResponse, this.malwareScanServiceImpl.scanMalware(DUMMY_STRING.getBytes(),DEFAULT_TIMEOUT, messages, "test-entity"));
    }

    @Test
    @Order(3)
    @DisplayName("test when malware scan service return null response.")
    void testWhenMalwareScanServiceReturnNullResponse() {
        ResponseEntity<MalwareScanResponse> result = new ResponseEntity<>(null, HttpStatus.OK);

        when(this.environment.getProperty(DUMMY_MALWARE_SERVICE_TIMEOUT, Integer.class)).thenReturn(DEFAULT_TIMEOUT);
        when(this.webClient.method(HttpMethod.POST)).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.bodyValue(DUMMY_STRING.getBytes())).thenReturn(requestHeadersSpecMock1);
        when(requestHeadersSpecMock1.headers(any(Consumer.class))).thenReturn(requestHeadersSpecMock2);
        when(requestHeadersSpecMock2.retrieve()).thenReturn(responseSpecMock);
        when(responseSpecMock.toEntity(MalwareScanResponse.class)).thenReturn(responseEntityMock);
        when(responseEntityMock.block()).thenReturn(result);
        assertNull(this.malwareScanServiceImpl.scanMalware(DUMMY_STRING.getBytes(), DEFAULT_TIMEOUT, messages,"test-entity" ));
    }

    @Test
    @Order(2)
    @DisplayName("test when malware scan service raises webClientResponseException.")
    void testGetLogWhenMalwareScanServiceRaisesWebClientResponseException() {
        when(this.environment.getProperty(DUMMY_MALWARE_SERVICE_TIMEOUT, Integer.class)).thenReturn(DEFAULT_TIMEOUT);
        when(this.webClient.method(HttpMethod.POST)).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.bodyValue(DUMMY_STRING.getBytes())).thenReturn(requestHeadersSpecMock1);
        when(requestHeadersSpecMock1.headers(any(Consumer.class))).thenReturn(requestHeadersSpecMock2);
        when(requestHeadersSpecMock2.retrieve()).thenThrow(webClientResponseException);

        when(webClientResponseException.getRawStatusCode()).thenReturn(400);
        when(webClientResponseException.getResponseBodyAsString()).thenReturn(HTTP_ERROR_RESPONSE_BODY);
        when(webClientResponseException.getMessage()).thenReturn(SOMETHING_WENT_WRONG);

        assertNull(this.malwareScanServiceImpl.scanMalware(DUMMY_STRING.getBytes(), DEFAULT_TIMEOUT, messages, "ProfilePhoto"));
        List<ILoggingEvent> logsList = listAppender.list;
        assertEquals(1, logsList.size());
        assertEquals(Level.ERROR, logsList.get(0).getLevel());
        assertEquals(StringFormatter.format("{0} {1} returned error code {2}. Response Body: {3} Message: {4}",
                HttpMethod.POST.toString(), "https://" + DUMMY_URL + "/scan", 400, HTTP_ERROR_RESPONSE_BODY,
                SOMETHING_WENT_WRONG), logsList.get(0).getFormattedMessage());
    }

    @Test
    @Order(1)
    @DisplayName("test when malware scan service raises timeoutException.")
    void testGetLogWhenMalwareScanServiceRaisesTimeoutException() {
        WebClient.ResponseSpec localResponseSpecMock = mock(WebClient.ResponseSpec.class);
        Mono<ResponseEntity<MalwareScanResponse>> localResponseEntityMock = mock(Mono.class);
        when(this.environment.getProperty(DUMMY_MALWARE_SERVICE_TIMEOUT, Integer.class)).thenReturn(DEFAULT_TIMEOUT);
        when(this.webClient.method(HttpMethod.POST)).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.bodyValue(DUMMY_STRING.getBytes())).thenReturn(requestHeadersSpecMock1);
        when(requestHeadersSpecMock1.headers(any(Consumer.class))).thenReturn(requestHeadersSpecMock2);
        when(requestHeadersSpecMock2.retrieve()).thenReturn(localResponseSpecMock);
        when(localResponseSpecMock.toEntity(MalwareScanResponse.class)).thenReturn(localResponseEntityMock);
        doAnswer(new AnswersWithDelay(1500, new Returns(null))).when(localResponseEntityMock).block();

        assertNull(this.malwareScanServiceImpl.scanMalware(DUMMY_STRING.getBytes(), DEFAULT_TIMEOUT, messages, "ProfilePhoto"));
        List<ILoggingEvent> logsList = listAppender.list;
        assertEquals(1, logsList.size());
        assertEquals(Level.ERROR, logsList.get(0).getLevel());
        assertEquals(
                "Malware Scanning service took longer than expected: TimeLimiter 'MalwareScanningTimeLimiter' recorded a timeout exception.",
                logsList.get(0).getFormattedMessage());
    }

    @Test
    @Order(5)
    @DisplayName("test when malware scan service raises timeoutException for increased timeout (Attachment upload).")
    void testGetLogWhenMalwareScanServiceRaisesTimeoutExceptionForIncreasedTimeout() {
        WebClient.ResponseSpec localResponseSpecMock = mock(WebClient.ResponseSpec.class);
        Mono<ResponseEntity<MalwareScanResponse>> localResponseEntityMock = mock(Mono.class);
        when(this.webClient.method(HttpMethod.POST)).thenReturn(requestBodyUriSpec);
        when(this.environment.getProperty(DUMMY_MALWARE_SERVICE_TIMEOUT, Integer.class)).thenReturn(2000);
        when(requestBodyUriSpec.uri(anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.bodyValue(DUMMY_STRING.getBytes())).thenReturn(requestHeadersSpecMock1);
        when(requestHeadersSpecMock1.headers(any(Consumer.class))).thenReturn(requestHeadersSpecMock2);
        when(requestHeadersSpecMock2.retrieve()).thenReturn(localResponseSpecMock);
        when(localResponseSpecMock.toEntity(MalwareScanResponse.class)).thenReturn(localResponseEntityMock);
        doAnswer(new AnswersWithDelay(2500, new Returns(null))).when(localResponseEntityMock).block();

        assertNull(this.malwareScanServiceImpl.scanMalware(DUMMY_STRING.getBytes(), 2100, messages, "Resume"));
        List<ILoggingEvent> logsList = listAppender.list;
        assertEquals(1, logsList.size());
        assertEquals(Level.ERROR, logsList.get(0).getLevel());
        assertEquals(
            "Malware Scanning service took longer than expected: TimeLimiter 'MalwareScanningTimeLimiter' recorded a timeout exception.",
            logsList.get(0).getFormattedMessage());
        verify(messages, times(1)).error(MessageKeys.MALWARE_SCANNING_ERROR);
    }
}
